# 闭包

## 什么是闭包

《JavaScript 高级程序设计》中是这样描述的

> 闭包是指有权访问另一个函数作用域中的变量的函数

```JavaScript
const a = 10

function myFunc() {
  const a = 1
  return function () {
    console.log(a)
  }
}

const func = myFunc()
func() // 1
console.log(a) // 10
```

创建闭包最常见的方式就是在一个函数内部创建另一个函数, 所以很容易理解, 闭包其实就是一个可以访问其他函数内部变量的函数

上面的例子, `myFunc` 函数内部定义了变量 `a`, 同时返回了一个匿名函数, 匿名函数内部读取了变量 `a`. 正常情况下, 函数内部的变量在函数外部是无法访问的. 但是通过闭包, 是可以实现的

## 闭包是如何产生的

理解闭包产生的原因之前, 需要先了解一下作用域和作用域链

### 作用域

#### 全局作用域

JavaScript 最外层的执行环境, 在 Web 浏览器中, 指的是 `window` 对象, 而在 Node 环境中, 则是 `global`

#### 函数作用域

在函数中定义的变量叫做函数变量, 只有在函数内部才可以访问到, 所以变量所处的函数内部, 称为函数作用域

#### ES6 块级作用域

ES6 新增了新的声明变量的关键词 `let`, 通过 `let` 定义的变量只能在块级作用域中进行访问, 有"暂时性死区"的特点. 除了函数作用域之外, 只要是在花括号之间的部分, 就是块级作用域

```JavaScript
if (condition) { /* 块级作用域 */ }

for (let i = 0; i < condition; i++) { /* 块级作用域 */ }

{ /* 块级作用域 */ }
```

### 作用域链

当访问一个变量时, 会现在当前的作用域中进行查找, 如果没找到, 就去父级作用域去查找, 直到找到该变量或者查找失败. 这样的链路就叫做作用域链.

### 闭包产生的原因

那么回到闭包的话题上, 在闭包中, 访问了函数内部的变量, 根据作用域链向上进行查找, 由此可以得出闭包产生的原因: 当前作用域中存在指向父级作用域的引用

## 闭包的作用

1. 返回一个函数
2. 在定时器, 事件监听, Ajax 请求等, 只要使用了回调函数, 实际上就是在使用闭包

```JavaScript
// 定时器
setTimeout(() => {
  console.log('callback')
}, 1000)

// 事件监听
window.addEventListener('resize', () => {
  console.log('resize')
})
```

3. 作为函数参数传递

```JavaScript
function func(cb) {
  cb()
}
```

4. IIEF (立即执行函数)

```JavaScript
;(function IIFE() {
  console.log('IIFE')
})()
```
