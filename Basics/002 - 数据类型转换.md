# 数据类型转换

## 强制类型转换

- Number()
- parseInt()
- parseFloat()
- String()
- toString()
- Boolean()

## 隐式类型转换

当进行加减乘除, 逻辑运算时, 如果运算符两侧的数据类型不一致, JS 将对其中一侧进行必要的类型转换, 当两侧数据类型一致时, 才能完成相应的运算. 这种由编译器自动转换的方式就成为隐式转换.

### 减乘除 - \* /

当参与运算的一侧为非 Number 类型时, 则先转换成 Number 后再进行运算

### 加 +

1. 当一侧为 String 类型时, 识别为字符串拼接, 另一侧转换成 String 类型
2. 当一侧为 Number 类型时, 另一侧为原始类型, 则将原始类型转换为 Number 类型
3. 当一侧为 Number 类型时, 另一侧为引用类型, 则将引用类型和 Number 类型转换成字符串后拼接

| 类型 A | 类型 B  | ->  | 类型 A | 类型 B |
| :----: | :-----: | :-: | :----: | :----: |
| String |   Any   | ->  | String | String |
| Number | Default | ->  | Number | Number |
| Number | Object  | ->  | String | String |

### 比较运算符 ==

1. NaN 与其它类型比较永远返回 false (包括它自己)
2. 当一侧为 Boolean 类型时, 则转换为 Number 类型
3. 当为 String 和 Number 类型时, 则将 String 类型转换为 Number 类型
4. 当一侧为 Symbol 类型时, 则返回 false
5. 当一侧为 undefined 或 null 时, 另一侧必须为 undefined 或 null, 才会返回 true, 否则返回 false
6. 当为 Object 和原始类型时, 则将 Object 类型, 依照 toPrimitive 规则转换为原始类型, 如果还是没法转换成原始类型, 则抛出 TypeError 错误

> toPrimitive 规则: 尝试依次调用对象的 `[Symbol.toPrimitive]`, `valueOf()` 和 `toString()` 方法, 将对象转换为原始类型的值
